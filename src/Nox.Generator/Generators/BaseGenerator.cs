using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using Nox.Solution;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Nox.Generator.Generators
{
    internal abstract class BaseGenerator
    {
        protected GeneratorExecutionContext Context { get; }

        private protected BaseGenerator(GeneratorExecutionContext context)
        {
            Context = context;
        }

        public static string ToLowerFirstChar(string input)
        {
            if (string.IsNullOrEmpty(input))
            {
                return input;
            }

            return char.ToLower(input[0]) + input.Substring(1);
        }

        protected void GenerateFile(StringBuilder sb, string className)
        {
            var hintName = $"{className}.g.cs";
            var source = SourceText.From(sb.ToString(), Encoding.UTF8);

            Context.AddSource(hintName, source);
        }

        protected void AddRelationships(IEnumerable<EntityRelationship> relationships, StringBuilder sb)
        {
            foreach (var relationship in relationships)
            {
                AddRelationship(sb, relationship);
            }
        }

        protected void AddRelationship(StringBuilder sb, EntityRelationship relationship)
        {
            string typeDefinition;

            // Is Many
            if (relationship.Relationship == EntityRelationshipType.ZeroOrMany || relationship.Relationship == EntityRelationshipType.OneOrMany)
            {
                typeDefinition = $"IList<{relationship.Entity}>";
            }
            else
            {
                // Nullable or not check
                typeDefinition = relationship.Relationship == EntityRelationshipType.ExactlyOne ? $"{relationship.Entity}" : $"{relationship.Entity}?";
            }

            AddProperty(typeDefinition, relationship.Name, sb);
        }

        protected static void AddSimpleProperty(NoxType type, string name, bool isRequired, StringBuilder sb)
        {
            var typeName = ClassDataType(type);
            // Do not generate "string?" - TODO: make configurable
            AddProperty(isRequired || typeName == "string" ? typeName : $"{typeName}?", name, sb);
        }

        protected static void AddProperty(string type, string name, StringBuilder sb, bool initOnly = false)
        {
            sb.AppendLine($@"   public {type} {name} {{ get; {(initOnly ? "init" : "set")}; }}");
            sb.AppendLine($@"");
        }

        protected static void AddConstructor(StringBuilder sb, string className, Dictionary<string, string> parameters)
        {
            sb.AppendLine($@"   public {className}(");
            for (int i = 0; i < parameters.Count; i++)
            {
                var parameter = parameters.ElementAt(i);
                sb.AppendLine($@"      {parameter.Key} {ToLowerFirstChar(parameter.Value)}{(i < parameters.Count - 1 ? "," : "")}");
            }
            sb.AppendLine($@"      )");
            sb.AppendLine($@"   {{");
            foreach (var value in parameters.Select(p => p.Value))
            {
                sb.AppendLine($@"      {value} = {ToLowerFirstChar(value)};");
            }
            sb.AppendLine($@"   }}");
            sb.AppendLine($@"");
        }

        protected static string GetParametersString(IEnumerable<DomainQueryRequestInput> input, bool withDefaults = true)
        {
            // TODO: switch to a general type resolver
            return string.Join(", ", input
                .Select(parameter => $"{(parameter.Type == NoxType.Entity ? ClassDataType(parameter.Type) : parameter.EntityTypeOptions.Entity)} {parameter.Name}{(withDefaults ? parameter.IsRequired : string.Empty)}"));
        }

        protected static string GetParametersExecuteString(object entity)
        {
            return string.Join(", ", ((List<object>)entity).Cast<Dictionary<object, object>>()
                .Select(parameter => $"{parameter["name"]}"));
        }

        protected static void AddDbContextProperty(StringBuilder sb)
        {
            AddProperty("NoxDomainDbContext", "DbContext", sb, initOnly: true);
        }

        protected static void AddAttributes(IEnumerable<NoxSimpleTypeDefinition> attributes, StringBuilder sb)
        {
            foreach (var attr in attributes)
            {
                AddSimpleProperty(attr.Type, attr.Name, attr.IsRequired, sb);
            }
        }

        protected static void AddNoxMessangerProperty(StringBuilder sb)
        {
            AddProperty("INoxMessenger", "Messenger", sb, initOnly: true);
        }

        protected static void AddBaseTypeDefinition(
            StringBuilder sb,
            string className,
            string? parent,
            string noxNamespace,
            bool isAbstract = false,
            bool isPartial = false,
            params string[] namespaces)
        {
            sb.AppendLine($@"// autogenerated");
            foreach (var val in namespaces)
            {
                sb.AppendLine($@"using {val};");
            }

            sb.AppendLine($@"");
            sb.AppendLine($@"namespace {noxNamespace};");
            sb.AppendLine($@"");
            sb.AppendLine($@"public {(isAbstract ? "abstract " : string.Empty)}{(isPartial ? "partial " : string.Empty)}class {className} {(parent == null ? string.Empty : $": {parent}")}");
            sb.AppendLine($@"{{");
        }

        // TODO: should be replaced by Nox.Types - temporaly use dotnet types
        protected static string ClassDataType(NoxType type)
        {
            return type switch
            {
                NoxType.Text => "string",
                NoxType.Guid => "Guid",
                NoxType.Date => "DateTime",
                NoxType.DateTime => "DateTime",
                NoxType.Boolean => "bool",
                NoxType.Object => "object",
                NoxType.Number => "int",
                _ => "string"
            };
        }
    }
}
